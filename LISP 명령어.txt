※ 전역변수 정의 함수 ※

(defparameter <심볼(sybol)> <값>) - 전역변수에 값을 쓰면 이전에 저장된 모든 값을 덮어씌운다.
(defvar <sybol> <값>) - 전역변수의 이전 값을 덮어쓰지 않는다.

Ex ---------------▼
> (defparameter *foo* 5)
*FOO*
> *foo*
5
> (defparameter *foo* 6)
*FOO*
> *foo*
6
> (defvar *foo* 5)
*FOO*
> *foo*
5
> (defvar *foo* 6)
*FOO*
> *foo*
5
---------------------

※ 전역함수 정의 ※

(defun function_name (arguments)
	...)

Ex ------------------
> (defun guess-my-number ()
       (ash (+ *small* *big*) -1))
GUESS-MY-NUMBER
---------------------

위의 빈 괄호는 이 함수는 매개변수가 없다는 것이다.
예제를 보면 ash라는 명령어가 있는데 이는 산술 시프트 함수이다.
ash는 입력받은 숫자를 이진수 형태로 바꾸어 비트를 왼쪽이나 오른쪽으로 시프트하면서 값을 버리기도 한다.
(*Tip*)
리스프에서는 return이 필요 없으며, 함수 몸체에서 계산된 마지막 값이 자동으로 반환된다.

ash 함수 Ex----------
> (ash 11 1)   <-- 11을 이진수로 하면 1011이다. 이처럼 왼쪽으로 한 칸 시프트하면..
22             <-- 10110인 22를 산출한다.
> (ash 11 -1)  <-- 오른쪽으로 한 칸 시프트하면..
5              <-- 101인 5를 산출한다.
---------------------

※ 지역변수 정의 ※

(let (variable declarations)
  ...body...)

let 명령 구조의 첫 번째 인자는 변수 정의 목록이다. 한 개 이상의 지역변수 정의 가능하다.

Ex ------------------
> (let ((a 5)
	(b 6))
      (+ a b))
11
---------------------

(flet ((function_name (arguments)
	...function body...))
 ...body...)

Ex2 -----------------
> (flet ((f (n)
	    (+ n 10)))
	(f 5))
15
---------------------

위의 예제에서 인자 n을 받는 함수 f를 정의하고, f함수는 전달된 n에 10을 더한다.
f함수에 인자로 5를 넣어서 실행하면 15를 결과로 받는다.

Ex3 -----------------
> (flet ((f (n)
	    (+ n 10))
	 (g (n)
	    (- n 3)))
	(g (f 5)))
12
---------------------

위의 예제를 보면 flet도 let처럼 지역함수 여러 개를 정의할 수 있다.
f함수와 g함수를 선언하여 f에는 먼저 5를 넣어 15를 산출하고 g함수에서 3이 빠져 최종결과로 12가 나온다. (+ 2(- 5 2))의 경우 5에서 2를 빼고 2를 더해서 5를 결과로 받는다. 위의 예제 (g (f 5))에서도 f에 인자 5를 넣고 다시 맨위로 가서 10을 더하고 (g (n)에는 15를 인자로 받고 그 값에서 3을 빼주어서 값12를 결과로 받는다.

Ex4 -----------------
> (flet ((f (n)
	    (+ n 10))
	 (g (n)
	    (- n 3)))
	(f 5))
15
---------------------

만약 Ex4처럼 g를 선언만 한다면, 인자를 넣어준 f 함수만 실행이 된다.
다음은 지역함수 정의 내에서 다른 지역함수를 사용하기 위한 명령 labels을 살펴보자.

Ex5 -----------------
> (labels ((a (n)
	      (+ n 5))
	   (b (n)
	      (+ (a n) 6)))
	(b 10))
21
---------------------

예제를 보면 flet명령의 기본 구조와 동일하다는 것을 알 수 있다.
지역함수 a는 숫자에 5를 더한다. 그 다음은 함수 b 정의이다. 함수 a를 실행하고 그 결과값에 6을 더한다. 마지막 줄은 함수b에 10을 넣어 실행한다.
여기서 flet과는 다른 점이 나타나는데, Ex3에서 f함수에 5를 넣어 실행하지만 여기서는 함수 b의 내부에서 함수 a를 실행한다. flet을 썼다면 함수 b는 함수 a가 무엇인지 '알지' 못했을 것이다. labels 명령은 다른 지역함수를 실행하고, 자기 자신을 다시 실행할 수도 있다. 이를 재귀호출이라고 부른다.

Ex6 -----------------
> (labels ((a (n)
	      (+ n 5))
	   (b (n)
	      (+ (a n) 6)))
	(a 10))
15
---------------------

만약 여기서 a 함수에 인자를 준다면 함수a는 함수b를 '알지' 못하기 때문에 a함수만을 실행한다.

※ 리스프 문법의 기초 ※

리스프의 문법은 흔히 리스퍼들이 판독기라고 일컫는 리스프 컴파일러 또는 리스프 인터프리터에서 코드를 받아들이는 부분은 C나 다른 프로그래밍 언어보다 간단하다. 리스프의 예제들을 한번 보고 오면 사실 이것은 괄호로 구분된 중첩 리스트로 볼 수도 있다. 리스프는 괄호를 사용해 코드를 오직 리스트로만 작성한다.
이 리스트 안에는 리스트와 함께 심볼이나 숫자, 문자열을 넣을 수 있다. '리스트 문법의 기초'항목에서는 기초적인 구조와 자료형에 관해 나온다.

*심볼*

심볼은 리스프에서 사용하는 기본 데이터 타입이다. 하나의 심볼은 하나의 독립적인 단어이다. Common LISP의 심볼은 보통 문자나 숫자, + - / * = < > ? ! +_ 등과 같은 기호로 이루어진다. 커먼 리스프에서 심볼은 대소문자 구분이 없다.
여기서 하나의 예제에 두 심볼이 같은지 알아보는 함수인 eq 함수를 사용해보겠

Ex1 -----------------
> (eq 'fooo 'foOo)
T
---------------------

코드에서는 두 심볼이 같다고 알리기 위해 T를 리턴한다.

*숫자*

리스프에서는 실수형과 정수형 모두 지원한다. 코드에 숫자를 쓸 때 소수점을 사용해 실수형과 정숳ㅇ을 결정한다. 1과 1.0은 보통 모두 1로써 인식하지만 리스프는 다른 숫자로 인식한다. 정수형과 실수형을 같이 인자로 받는 대부분의 수학 함수에서는 정수형 숫자가 실수형으로 '바뀌고', 결과는 실수형의 값으로 리턴된다.

Ex1 -----------------
> (+ 1 1.0)
2.0
---------------------

보통 리스프에서 (+ 1 1)을 하면 값은 2를 리턴한다. 하지만 이번엔 1.0인 실수형을 넣었더니 2.0이 리턴되었다. 그 다음은 제곱을 구하는 함수 expt를 사용해보자.

Ex2 -----------------
> (expt 53 53)
24356848165022712132477606520104725518533453128685640844505130879576720609150223301256150373
---------------------

리스프에서는 이런 큰 숫자의 계산이 가능하다. 그 다음으로는 두 정수를 나눌 때 뭔가 뜻하지 않는 일이 생기는 것을 볼 수 있을 것이다.

Ex3 -----------------
> (/ 4 6)
2/3
---------------------

위의 예제는 4를 6으로 나눈 값이다. 0.6666..처럼 나누어 떨어지지 않는 무한소수가 반환되지 않고 유리수 형태로 값이 반환된다. 하지만 식에 실수 형태를 넣는다면 결과는 달라질 것이다.

Ex4 -----------------
> (/ 4.0 6)
0.6666667
---------------------

여기서 실수형을 집어넣으면 결과도 무한소수인 실수형태로 나오는 것을 볼 수 있다.

*문자열*

리스프에서는 문자열을 표현하고자 "Hello"와 같이 겹따옴표로 둘러싼다. princ 함수를 사용하면 문자열을 출력할 수 있다.

Ex1 -----------------
> (princ "Hello Lisp")
Hello Lisp
"Hello Lisp"
---------------------

REPL에서(판독-평가-출력의 반복 과정) 두 번 출력하는 것을 볼 수 있다. 먼저 princ 명령에 의해 값을 출력하고 REPL은 항상 입력한 코드의 결과를 출력하기 때문에 입력값이 다시 출력된다. princ 함수에서는 그 입력값을 결과로 반환하기 때문이다.

또한 문자열은 이스케이프 문자를 포함할 수 있다. 그러니까 무슨 이야기인가 하면은 문자열을 출력할때, 
예를 들어 게임 캐릭터가 말을 할때 "(쌍따옴표)를 붙여서 출력을 하고 싶을 경우.

Ex1 -----------------
> (princ "Lisp : \" Lisp를 공부합시다. \" ")
Lisp : " Lisp를 공부합시다. "
"Lisp : \" Lisp를 공부합시다. \" "
---------------------

리스프에서는 위의 예제처럼 겹따옴표 앞에 쓰인 역슬래시 덕분에 이 따옴표가 문자열의 일부로 간주되기 때문에 다른 문자와 같이 출력되었다.

※ 리스프가 코드인지 데이터인지 구별하는 방법 ※

리스프가 코드와 데이터를 구별하는 방법에는 코드 모드와 데이터 모드 두 가지 방식을 사용한다. 이 모드는 리스프 코드를 짜면서 두 가지 중 다른 한 모드로 바꾸는 것도 가능하다.

*코드 모드*

리스프 REPL(판독-평가-출력의 반복 과정)에 뭔가를 작성할 때 컴파일러는 이를 실행하려는 명령어를 입력하는 것으로 추측한다. 다시 말해 리스프는 기본적으로 코드 모드에서 받아들인다는 것이다.
리스프는 리스프 코드가 리스트로 입력되리라 추측할 텐데, 이 리스프 코드는 조금 특별한 형태를 갖춘 리스트여야 한다.
코드 모드일 때, 즉 REPL에 명령어를 넣을 때는 이 형태에 맞추어야 한다.

보통 함수 이름과 같은 특별한 명령어가 앞에 나오는 간단한 리스트 형태다.
이 리스트 형태를 읽을 때, 리스프는 리스트 안의 다른 아이템을 함수에 매개변수로 전달한다.

Ex1 -----------------
> (expt 2 3)
8
---------------------

위의 예제는 제곱 연산을 하는 expt 함수이다. 첫 부분에 함수 이름을 위치시키는 리스프의 표준대로 명령을 입력했다. 이 명령문처럼 리스프에서 인자를 읽을 때는 보통 이 매개변수 또한 코드 모드로 해석된다. 

Ex2 -----------------
> (expt 2 (+ 3 4))
128
---------------------

다음의 예제는 리스트 두 개가 중첩된 형태이다. 처음에 리스프는 코드 모드에서 전체적인 표현식을 살핀다. 그 다음은 expt 함수에 맞는 형태로 값이 입력되었는지 확인한다. 여전히 코드 모드인 상태에서 expt 함수의 인자를 살핀다. 인자 중하나인 (+ 3 4)는 리스트의 오른쪽에 위치한다. (+ 3 4)는 하나의 리스트 형태로 인식하여 7을 산출한다. 그러면 (+ 3 4)의 바깥의 리스트에서 결과값 7이 expt함수에 전달되어 2의 7제곱의 결과값을 반환한다.

*데이터 모드*

당연한 말이지만, 데이터 모드로 쓰인 모든 것은 데이터로 취급한다. 즉 컴퓨터가 '실행'하려 하지 않는 순수 데이터 정보를 코드 안에 넣을 수 있다는 것을 의미한다.

Ex1 -----------------
> '(expt 2 3)
(expt 2 3)
---------------------

리스트 맨 앞에 홑따옴표를 넣으면 코드 모드에서는 2의 3제곱인 8을 출력하지만 그 대신에 입력한 결과를 다시 출력한다. 여기서 홑따옴표는 리스프에게 홑따옴표 다음 부분을 데이터 절, 다시 말해 그냥 아이템이 든 리스트로 취급하라는 것이다. 그리고 평과 결과로서 리스트를 그대로 출력한다. 이 과정에서 리스트 안의 함수와 변수가 모두 무시되어 그냥 데이터로 취급된다.

홑따옴표를 리스트 앞에 붙여 명령어로 처리되지 않게 하는 것을 인용이라고 한다.
 인용 처리를 통해서 리스프에게 다음 부분은 명령어가 아니고 프로그램 안에서 쓰는 데이터라는 것을 알릴 수 있다.

*리스트*

리스트는 리스프에서 가장 중요한 부분이다.
코드뿐만 아니라 모든 데이터를 함께 담고 있다.

(expt 2 3)

이 코드는 심볼(expt)과 숫자 두 개를 포함하고 괄호로 된 리스트 안에 같이 들어있다.
리스프 프로그램은 하나의 집이라고 생각이 가능하다.
리스프를 이용해 집을 짓기로 했다면, 벽은 아마 리스트로 짜여 있을 것이고, 벽돌은 심볼, 숫자, 문자열로 이루어졌을 것이다. 또한 그것을 고정할 회반죽이 필요할 것이며, 리스프에서는 콘셀 구조로 리스트를 고정한다.

*콘셀*

콘셀은 두 개의 작은 박스가 붙어있는 형태이고 각각 다른 콘셀 또는 다른 종류의 데이터를 가리킬 수도 있다. 이렇게 각각 하나씩 모두 두 개를 가리킬 수 있으므로 콘셀을 연결해 리스트를 만들 수 있다. 사실 리스트는 추상적인 표현일 뿐이고, 모든 것은 콘셀로 이루어져 있다.















(setq <심벌> <표현식> [<심벌> <표현식>]...)
setq 전역변수의 값을 수정하는 함수
(defun 함수명(인수 / 지역변수 ...) <표현식> ...)
defun 사용자 정의 함수
(princ [식] [파일-기술어])
princ 화면 출력 함수
(gcd  <숫자1> <숫자2>)
GCD두 수의 최대 공약수를 구하는 함수이다.
(rem  <숫자1> <숫자2> ...)
숫자 1을 2로 나눈 나머지 값을 구한다. (c의 %연산자와 비슷하다.)
(log  <숫자1>)
숫자의 자연 로그를 계산하고 실수로 리턴
(exp  <숫자1>)
자연 로그의 밑인 e의 숫자승을 계산하고 리턴
(expt  <밑수> <power>)
(expt 2 5)   = > 32
(sqrt  <숫자>)
숫자의 제곱근을 계산하고 결과 리턴
(abs <숫자>)
절대값 리턴
(sin  <각도>)
(cos  <각도>)
(tan <각도>)
(atan <숫자> [숫자])
???
(max <숫자> <숫자> ...)
가장 큰 수를 리턴
(min <숫자> <숫자> ...)
가장 작은 수를 리턴
(minusp <항목>)
음수이면 T를 리턴하고 음수가 아니면 nil을 리턴
(zero <항목>)
항목이 0(zero)이면 T를 리턴하고 0이 아니면 nil을 리턴한다.

(LIST <식> ...)
(`<식>)

LIST 조작 함수

(car <LIST>) list의 첫번째 요소 리턴 만약 없다면 nil
(cadr <LIST>) list의 두번째 요소 리턴
(caddr <LIST>) list의 세번째 요소 리턴
(cdr <LIST>) list의 첫번째를 제외한 나머지 리턴
(last <LIST>) list의 마지막 리턴
(nth <n> <LIST>) list의 n번째 요소 리턴
(length <LIST>) list의 개수를 정수로 리턴
(append <LIST> ...) list들을 하나의 list로 합친다.
(cons <항목1> <항목2>) 
(listp <항목>) 항목이 list이면 t, 아니면 nil 리턴
(member <식> <LIST>) 입력한 식이 list에 존재할 경우 그 식을 포함한 나머지 부분을 list로 리턴하고 존재하지 않으면 nil을 리턴
(reverse <LIST>) list의 내용을 거꾸로 리턴
(apply <함수> <LIST>)
(mapcar <함수> <LIST> ... <LIST>)
(assoc <항목> <LIST>)



